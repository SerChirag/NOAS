<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <link rel="icon" href="favicon/">
    <link rel="apple-touch-icon" sizes="57x57" href="favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>nRF</title>

    <meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
    <meta name="viewport" content="width=device-width" />

    <link href="bootstrap3/css/bootstrap.css" rel="stylesheet" />
    <link href="assets/css/gsdk.css" rel="stylesheet" />
    <link href="assets/css/demo.css" rel="stylesheet" />

    <!--     Font Awesome     -->
    <link href="bootstrap3/css/font-awesome.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Grand+Hotel' rel='stylesheet' type='text/css'>
    <link href="https://fonts.googleapis.com/css?family=Raleway|Roboto+Condensed" rel="stylesheet">
</head>

<body>
    <div id="navbar-full">
        <div class="container">
            <nav class="navbar navbar-ct-blue navbar-transparent navbar-fixed-top" role="navigation">

                <div class="container">
                    <!-- Brand and toggle get grouped for better mobile display -->
                    <div class="navbar-header">
                        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                        <a href="http://noas.iitmandi.ac.in/">
                            <div class="logo-container">
                                <div class="logo">
                                    <img id="noas_logo" src="images/logo_svg.svg">
                                </div>
                                <div class="brand">
                                    NOAS
                                </div>
                            </div>
                        </a>
                    </div>

                    <!-- Collect the nav links, forms, and other content for toggling -->
                    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
		              <ul class="nav navbar-nav navbar-right">
		                    <li><a href="publications.html">Publications</a></li>
		                    <li><a href="people.html">People</a></li>
		                    <li class="projects">
		                      <a href="#" class="dropdown-toggle" data-toggle="dropdown">Projects<b class="caret"></b></a>
		                      <ul class="dropdown-menu">
		                        <li><a href="nRF.html">nRF Network</a></li>
		                        <li><a href="MQTT.html">MQTT</a></li>
		                        <li><a href="ambysens.html">AmbYsenS</a></li>
		                      </ul>
		                    </li>
		                    <li class="External Links">
		                      <a href="#" class="dropdown-toggle" data-toggle="dropdown">External Links<b class="caret"></b></a>
		                      <ul class="dropdown-menu">
		                        <li><a href="http://iitmandi.ac.in/Schools/SCEE">School</a></li>
		                        <li><a href="http://www.iitmandi.ac.in">Institute Home</a></li>

		                      </ul>
		                    </li>
		                    <!--<button class="btn btn-primary" data-toggle="modal" data-target="#myModal">
		                      Launch demo modal
		                    </button>-->
		                    <li><button href="#gsdk" class="btn btn-round btn-default" data-toggle="modal" data-target="#myModal">Contact Us</button></li>
		                    
		               </ul>
		              
		            </div>
                    <!-- /.navbar-collapse -->
                </div>
                <!-- /.container-fluid -->
            </nav>
        </div>
        <!--  end container-->

        <div class='blurred-container'>

            <div class="img-src" style="background-image: url('images/board.jpg')"></div>
            <div class='img-src blur' style="background-image: url('images/board_blur.jpg')"></div>
        </div>

    </div>

    <div class="main">
        <div class="container tim-container" style="max-width:800px; padding-top:100px">

            <h1 class="text-center" >nRF network and Node-red</h1>
            <h3>This project was done by G. K. Sriharsha. His project report can be found <a href="reports/sriharsha.pdf">here</a>.</h3>
            <h2>Goal</h2>
            <p>The goal of this project is to design a wireless sensor network that uses nRFL2401 as radio module and communicates through MQTT protocol. </p>
            <h2>Getting started</h2>
            <p>For this project, we will be needing the following hardware and software</p>
            <table class="table table-hover">
            	<thead class="thead-inverse">
				    <tr>
				      <td class="c1"><b>Hardware </b></td>
                      <td class="c2"><b>Software </b></td>
				    </tr>
			  	</thead>
                
                <tr class="r2">
                    <td class="c1">Raspberry Pi (Model 3B) &ndash; 1 no</td>
                    <td class="c2"> <a href="https://www.arduino.cc">Arduino IDE</a> </td>
                </tr>
                <tr class="r3">
                    <td class="c1">Arduino UNO (V3) &ndash; 2 nos </td>
                    <td class="c2"> Python </td>
                </tr>
                <tr class="r4">
                    <td class="c1">nRF24l01 radio modules &ndash; 3 nos </td>
                    <td class="c2"> <a href="https://mosquitto.org">Mosquitto</a> </td>
                </tr>
                <tr class="r5">
                    <td class="c1">DHT 11/22 &ndash; 2 nos </td>
                    <td class="c2"> <a href="https://github.com/VaclavSynacek/RF24SN">RF24Network</a> library </td>
                </tr>
                <tr class="r6">
                    <td class="c1">LDR &ndash; 2 nos </td>
                    <td class="c2"> <a href="https://nodered.org/">Node-red</a> </td>
                </tr>
                <tr class="r7">
                    <td class="c1">PIR &ndash; 2 nos </td>
                    <td class="c2">
                    </td>
                </tr>
            </table>
            <h2>A Customized network &ndash; A simple RF communication</h2>
            <p>In this network, there are only two sensor nodes. This is designed as a &lsquo;&lsquo;two-place" system. One node will be deployed outdoor with a power connection from a battery while the other node is kept inside connected to a wall socket. In this setup, there are two Arduinos and one Raspberry Pi. The Arduino used in the indoor deployment (master Arduino) is connected to Raspberry Pi via USB connection. The data transfer between the master Arduino and the Raspberry Pi is via Serial communication. The other Arduino, deployed outdoor (slave Arduino) communicates using the NRF board to the master Arduino which in turn forwards the data to the Raspberry Pi via USB.</p>

            <div align="center">
            <img src="images/Block_Diagram1.jpg" width="60%" height="60%" alt="Block diagram" title="Fig 1: Customized network, the one on the left is the receiver node and the one on the right is the slave node." />
                <p>
                	<i>
                		<div align="center">
                			Fig 1: Customized network, the one on the left is the receiver node and the one on the right is the slave node.
                		</div>
                		<br>
                		<br>
                		<br>
                	</i>
                </p>
            </div>

            <p>Since the Raspberry Pi does not have ADC support, LDR and other analog sensors must be connected to master Arduino. The python script is written such that it will signal the master Arduino to measure the analog value and send the data.The rest of the sensors (digital input/output) are connected to Raspberry Pi to reduce the load on Arduino.<br /> The functions of Python script in Raspberry Pi are</p>
            <ol>
                <li>
                    <p>To check,correct and update (if necessary) the timing interval of the slave Arduino</p>
                </li>
                <li>
                    <p>Signal the master Arduino for the sensor data</p>
                </li>
                <li>
                    <p>item Logging the sensor data into different files according to the type of measurement. (Computational and Non- computational)</p>
                </li>
            </ol>
            <div align="center">
            	<img src="images/Customized_Tx.png" alt="Transmitter" width="500px" height="400px" />
                <img src="images/Customized_Rx.png" alt="Receiver" width="500px" height="400px" />
                <p> 
                	<i>
                		<div>
                			Fig 2: Customized network: the one on the left is the slave node and the one on the right is the master node.
                		</div>
                	</i>
                </p>
            </div>
                    
                
            
            <h3>Execution of Python script in Raspberry Pi</h3>
            <p>Raspberry Pi has a Python script, running mainly for the above mentioned reasons. At the start of the execution, it asks user for the input.The user gets to choose among three modes.</p>
            <ol>
                <li>
                    <p><i>Power Saving Mode</i> - Once every 30 minutes, the sensor data is updated</p>
                </li>
                <li>
                    <p><i>Balanced Mode</i> - The user can set the update intervals of the nodes separately, with a value between 3 seconds to 30 minutes.</p>
                </li>
                <li>
                    <p><i>Aggressive Mode</i> - The nodes will be updating the data once every 20 seconds.</p>
                </li>
            </ol>

            <div align="center">
            	<img src="images/Customized2.png" alt="Python script output" width="100%" height="100%" />
                <p>
                	<i>
                		<div>
                			Fig 3: Output of the python script 
                		</div>
                		<br>
                		<br>
                		<br>
                	</i>
                <p>
            </div>
            <p>The slave node executes a code which keeps it in one of the two states. It is either listening constantly for an interrupt of its routine interval or it is transmitting the data at the end of the previously said interval.When a command is received, it will be in effect from next measurement.</p>
            <p>The Python code has a variable to keep in track of the measurement interval. It is an array of two numbers. The latest time (in milliseconds) is stored in the place of the older of the two times present. The difference of the two blocks gives the delay time of the two successive sensor data. If this is not equal to the interval which the user has set (within a margin of error), then the Python re-instructs the master node to set the selected interval for the slave node.The indoor part of the measurements happen from the Raspberry Pi itself, hence there is no need for keeping it in synchronization. A simple time tracker is enough to keep the measurement interval to a particular interval.</p>
            <p>Whenever the state of PIR sensor in slave node goes HIGH, then the listening stops and transmits a code which the master Arduino understands as an interrupt and can distinguish this from data. Master Arduino forwards this message to the Raspberry Pi after attaching the slave node address via USB. If there is a HIGH state for PIR attached to Raspberry Pi, then the message is directly logged with Raspberry Pi's address.If it is time for indoor measurement, the script sends a code which the master Arduino can decipher to be the request for LDR value. After measuring the LDR value, it is transmitted back via the same Serial connection.In this way the sensors are used to get the values for indoor and outdoor weather parameters. </p>
            <p>Advantages of this customized system</p>
            <ul>
                <li>
                    <p>It is best for small environments</p>
                </li>
                <li>
                    <p>Small payload size because there wont be a field for node address ,etc.</p>
                </li>
                <li>
                    <p>Easy to control and debug the system.</p>
                </li>
            </ul>
            <p>Disadvantages of this customized system</p>
            <ul>
                <li>
                    <p>Interoperability and heterogeneous nature is lacking ,i.e, a board with ESP communication board cannot be a part of the network </p>
                </li>
                <li>
                    <p>Actuation network cannot be created because of lack of interoperability. </p>
                </li>
                <li>
                    <p>There is no uniformity in message structure and communication.</p>
                </li>
            </ul>
            <h2>A Standardized solution &ndash; A structured network with MQTT</h2>
            <p>In order to counter the limitations of the previous network, a standardized approach is necessary to level out all the differences in nodes and their various modes of communication.In this solution, the Raspberry Pi is interfaced with NRF radio directly and a network is formed with it as a parent and the other Arduinos as children.This network is called <a href="https://github.com/VaclavSynacek/RF24SN/">RF24SN</a>. This network is responsible for the reception of data from Arduino sensor node to Raspberry Pi.</p>
            <p>Once the data is received into Raspberry Pi, it then published into an MQTT broker program running in the background. In this setup we have used open source software Mosquitto and its API to publish and subscribe data from the C script running in the Raspberry Pi. If a message is published in the topic of subscription, the C code is programmed to send an appropriate message to the nodes. For example, if a message is published into &ldquo;Settings<i>Knode1</i>Interval&rdquo; with 20 , then the interval of Node1 is set to 20 seconds by sending an appropriate message. In a similar way, a switch is programmed such that an individual measurement is turned off/on by publishing the message under the appropriate channel. For data interoperability, before publishing the data, it is converted into JSON format. This is done to all data coming into the MQTT server to maintain uniformity in the network.</p>
            <p>From the perspective of the MQTT broker, it is all about data being published and being re-routed to interested nodes. Due to a common JSON format, MQTT broker can directly send the data to the actuator node which can read the information after processing it.To the same MQTT broker,data from other nodes are published. The Raspberry Pi is configured in a way, to receive data from all kinds of radios available. It is at this level, all of the network converges to.</p>

            <div align="center">
            	<img src="images/Block_Diagram2.jpg" alt="block diagram" width="80%" height="80%" />
                <p><i><div>Fig 4: Block diagram of the MQTT network </div></i></p>
            </div>
            <br>
            <br>
            <br>
            <p>A RF24 network is created with Raspberry Pi as the parent to all the nodes (from now onwards we will call them Knodes). For ease of reference this network will be called ARK network (RF24SN + MQTT along with Knodes}. As of the time of project , there are two child nodes. The Knodes are programmed that they will be delivering the unique message with 5 parameters.</p>
            <p><tt>Battery level Temperature Light(%) Humidity PIR-State</tt></p>
            <p>The message is sent with sensor values in the variables. The packet when sent from node contains the source and the destination address. Hence, when the header is examined, the message and the routing details can be known. According to this source address, the data is identified to be from which of the nodes it has been sent. Once the node is identified, then the sensor values are read and posted into respective channels in the MQTT broker through mosquitto API to C<tt></tt>. The same code contains the section where it is connected to few interested channels. The data from these channels is notified to the program. It is coded to be subscribed to all channels under &lsquo;&lsquo;Settings&ldquo;, with the help of &lsquo;&lsquo;#&rdquo; wild card. Whenever a client publishes data under this channel, it is processed and the equivalent instruction is sent to the sensor node to which it is addressed by the client. For example , If the requirement is such that the interval of measurement for node1 is to be changed to 3 minutes , instead of the current value, then in the following line must be entered in the terminal.</p>
            <div class="infoblock">
                <div class="blockcontent">
                    <p>$ mosquitto_pub -t Settings/Knode1/Interval -m 180</p>
                </div>
            </div>
            <p>Once the above line is executed the data 180 seconds (=3 minutes) is received by the C script and it is sent in its own message structure. The first value is the address to sensor.The second value is the state of the sensor addressed in first value. The third value is the change in interval.</p>
            <p><tt>0 0 180</tt></p>
            <p>If the Temperature measurement must be switched off, in node1, then the following command is executed in terminal.</p>
            <div class="infoblock">
                <div class="blockcontent">
                    <p>$ mosquitto_pub -t Settings/Knode1/Temperature -m Off</p>
                </div>
            </div>
            <p><tt>1 0 0</tt></p>
            <p>where 1- Temperature<br /> 2 - Humidity<br /> 3 - PIR<br /> 4 - LDR<br /> 0 - OFF 1 - ON</p>
            <p>This particular system is working on push mode. The Knodes are being sent the timing information and hence are pushing the data into the Raspberry Pi. In future, we can also work on pull mode,i.e., data on demand. If monitoring of the system is not required and if the data is needed based on the demand of an external event, this mode can be used. In pull mode, the Knodes will be listening for a command from the Raspberry Pi.It will only measure the required values when instructed. This mode as an option can be integrated into the current system, to make it more versatile.</p>

            <div align="center"><img src="images/MQTT_output.png" alt="MQTT terminal output" width="80%" height="80%" />
                <p><i><div>Fig 5: MQTT running in the terminal </div></i></p>
                <br>
                <br>
                <br>
            </div>

            <p>Advantages of such Standardized system -</p>
            <ul>
                <li>
                    <p>It is a scalable network.</p>
                </li>
                <li>
                    <p>Interoperability between different kinds of nodes is possible.</p>
                </li>
                <li>
                    <p>Unified structure and a protocol is being followed.</p>
                </li>
                <li>
                    <p>An actuation network can be built anywhere in the network.</p>
                </li>
            </ul>
            <h2>Node Red - A Graphical Interface Solution</h2>
            <p>Node red is an application which is pre-installed in Raspberry Pi. It is a graphical programming tool, which works on Node.js. In Node Red, there are separate nodes modules which have some function associated with it. As soon as a node is executed, the control moves onto the next node module in the flow(the connected diagram in Node red is called a flow). In this way, a complex system can be designed with the help of individual small node modules connected in the way which completes the task.All the nodes start working on being triggered and output the desired function, this data can be used to trigger the next node module.The underlying architecture and communication protocol is similar to that of the previous model.</p>
            <p>A C script is written such that it receives the data from the NRF radio and prints it onto the command line, in the following format</p>
            <p><tt>Node_Number Temperature Humidity Light PIR_State  Battery_level</tt></p>
            <p>After this execution , Node Red gets call back to the flow with the result. The flow is created such that immediately after receiving the message, it is re-triggered to listen for the next message. In this way, it is in an infinite loop in listening to sensor data.</p>

            <div align="center"><img src="images/flow_1.png" alt="Node-red flow diagram" width="100%" height="100%" />
                <p><i><div>Fig 6: Flow diagram in the Node-red</div></i></p>
                <br>
                <br>
                <br>
            </div>

            <p>In the Input flow, there is an inject node module which injects a dummy message into the Radio node.On double clicking the node,an option can be seen to inject a message at the start of the deployment.It should be checked for the flow to start immediately after deploying it,else one should click the inject button to start the flow.Radio node is an execution node module in advanced section of the left pane. In this execution node module the following command should be given or a similar one based on the location of the executable script.</p>
            <div class="infoblock">
                <div class="blockcontent">
                    <p>$ sudo ./MQTTController (if the file is present in /home/pi directory)</p>
                    <p>OR</p>
                    <p>$ sudo ./filepath/MQTTController</p>
                </div>
            </div>
            <p>The loop node module is a function module found in the left pane. It is a place where a custom script can be executed and the data could be sent as output. The loop node will trigger the Radio node module as soon as receiving the data, thereby keep the forever loop in listening to the data.</p>
            <p>The green node in the flow is called debug node, its function is to show the message being passed through the connections in the flows. It is useful for when examining the system in detailed. The debug mode is disabled by clicking the green button attached to it. The &ldquo;Node separator&rdquo; is also a custom function node module. This node module is responsible for dividing the incoming data into two paths according to the node that has sent the data. </p>
            <p>The grey node modules are linking flows across pages. This is done for aesthetic purposes and to maintain the clarity in the flow diagram.</p>

            <div align="center"><img src="images/flow_2.png" alt="Node-red flow diagram" width="100%" height="100%" />
                <p><i><div class="more_space">Fig 7: Flow diagram in the Node-red </div></i></p>

            </div>

            <p>After splitting the data according to the base address, it is sent to the above flow. For explanation purposes, the flow for one sensor node (Arduino board) is shown but exactly similar flow is designed for other sensor nodes (Arduino board) too. </p>
            <p>The data is sent from the grey linking nodes. The split node is responsible for splitting the tab spaced data into individual values.For example</p>
            <p><tt>2 23.4523 66.9822 89 0 43</tt> <br /> into <br />
                <tt>2<br />
23.4523<br />
66.9822<br />
89<br />
0<br />
43</tt></p>

            <div align="center"><img src="images/flow_5.png" alt="Node-red flow diagram" width="100%" height="100%" />
                <p><i><div class="more_space">Fig 8: Flow diagram in the Node-red</div></i></p>
            </div>

            <p>This part of the flow has input from the UI. There are switches integrated into UI for switching an individual measurement between On and Off.Once the state is toggled or the interval of measurement is changed.the node triggers the next node module with the payload.</p>
            <p>The node module named Sync sets the Radio variable to Output, in this state, the Radio node in the first flow stops working.It, then starts executing the transmission script which is connected to MQTT broker.</p>
            <p>In parallel to this, the code will be delayed by 1 second in the other branch to initiate the transmission script and initialize the radio for it. Then the publish node changes the payload value into an appropriate message for the script to understand. It is then published under the topic in the MQTT broker.</p>
            <p>The C script will be waiting for a value to be received via MQTT. Once the value is received, it changes the payload into a format the sensor node understands and send it to the addressed node. The code for the sensor node (Knode) is written such that after every update , it checks if any data is transmitted from the Pi. On receiving the data to the sensor node, it alters the measurement parameters and continues in the new state.The C script in Raspberry Pi will terminate after sending the data. The Sync function is executed which sets the radio value to read mode. This linking node will trigger the reading exec node module in 1st flow.</p>
            <p>A guage is connected to the slider to show the interval in seconds. The final output in the UI page is</p>

            <div align="center"><img src="images/Nodered.png" alt="Node-red UI" width="100%" height="100%" />
                <p><i><div class="more_space">Fig 9: Node-red dashboard UI</div></i></p>
            </div>

            <h3>Advantages of using Node Red -</h3>
            <ul>
                <li>
                    <p>Very good GUI is present, which can be used to visualize the data.</p>
                </li>
                <li>
                    <p>Easily understandable due to its graphical nature.</p>
                </li>
                <li>
                    <p>Little to no programming experience required.</p>
                </li>
                <li>
                    <p>If an improvement is required, it can be highly localized to replacing one to two nodes which carry out the specified functionality.</p>
                </li>
                <li>
                    <p>It can be used to run bits of code from other languages with the help of exec node which instructs from command line.</p>
                </li>
            </ul>
            <h3>Lesson learned and challenges faced</h3>
            <p>There are quite a few challenges faced while setting up the network.Some of them are -</p>
            <ul>
                <li>
                    <p>Raspberry Pi was connected to a network which has proxy configured.</p>
                </li>
                <li>
                    <p>Int data type, is not of the same size in Raspberry Pi and Arduino and hence when any data is transfered, it was being corrupted at the other end. Instead <tt>uint32t</tt> as a datatype.</p>
                </li>
            </ul>
            <h2>Conclusion and Future scope </h2>
            <p>In the above ways, a wireless sensor network can be setup for sensing the required parameters. These are first few steps in building a wireless sensor network which is extremely, optimized and streamlined for its use. There are still a few flaws with the current model of network. Working on them will be the future scope of this project. </p>
            <p>Some of the flaws in the system are</p>
            <ul>
                <li>
                    <p>The sleep modes are not effective due to power wastage from power and other LEDs</p>
                </li>
                <li>
                    <p>The payload can be reduced by using MQTT-SN structure than MQTT itself.</p>
                </li>
                <li>
                    <p>The GUI and communication in Node Red can be further optimized by using a HTTP socket or Serial port communication instead of a call back from terminal.</p>
                </li>
            </ul>
            <h2>References</h2>
            <ul>
                <li>
                    <p><a href="http://homeautomationforgeeks.com/rf24hardware.shtml">Home Automation project</a></p>
                </li>
                <li>
                    <p><a href="http://www.npmjs.com">Node package manager</a>: Resources for separate node modules.</p>
                </li>
            </ul>

        </div>

        <div class="row">
            <div class="col-md-6">

                <!-- Modal -->
                <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
                                <h4 class="modal-title" id="myModalLabel">Contact Form</h4>
                            </div>
                            <div class="modal-body">

                                <div class="form-group">
                                    <input type="text" value="" placeholder="Name" class="form-control" />
                                </div>

                                <div class="form-group">
                                    <input type="text" value="" placeholder="Contact Number" class="form-control" />
                                </div>

                                <div class="form-group">
                                    <input type="text" value="" placeholder="Email-ID" class="form-control" />
                                </div>

                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-default btn-simple" data-dismiss="modal">Close</button>
                                <div class="divider"></div>
                                <button type="button" class="btn btn-info btn-simple">Save</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>



</body>

<script src="jquery/jquery-1.10.2.js" type="text/javascript"></script>
<script src="assets/js/jquery-ui-1.10.4.custom.min.js" type="text/javascript"></script>

<script src="bootstrap3/js/bootstrap.js" type="text/javascript"></script>
<script src="assets/js/gsdk-checkbox.js"></script>
<script src="assets/js/gsdk-radio.js"></script>
<script src="assets/js/gsdk-bootstrapswitch.js"></script>
<script src="assets/js/get-shit-done.js"></script>
<script src="assets/js/custom.js"></script>

<script type="text/javascript">
    $('.btn-tooltip').tooltip();
    $('.label-tooltip').tooltip();
    $('.pick-class-label').click(function() {
        var new_class = $(this).attr('new-class');
        var old_class = $('#display-buttons').attr('data-class');
        var display_div = $('#display-buttons');
        if (display_div.length) {
            var display_buttons = display_div.find('.btn');
            display_buttons.removeClass(old_class);
            display_buttons.addClass(new_class);
            display_div.attr('data-class', new_class);
        }
    });
    $("#slider-range").slider({
        range: true,
        min: 0,
        max: 500,
        values: [75, 300],
    });
    $("#slider-default").slider({
        value: 70,
        orientation: "horizontal",
        range: "min",
        animate: true
    });
    $('.carousel').carousel({
        interval: 4000
    });
</script>

</html>